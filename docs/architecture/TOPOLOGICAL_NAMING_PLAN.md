# Topological Naming Engine - Implementation Plan

## Executive Summary

This document outlines the architecture and implementation plan for a **Persistent Topological Naming System** in HiveCAD. This is the critical missing piece that prevents HiveCAD from achieving Onshape/Fusion 360-level parametric modeling robustness.

### The Problem

Currently, HiveCAD references geometry by **transient index** (e.g., `shape1:face-0`). When the model history changes (adding/removing features, modifying sketches), the topology regenerates with potentially different indices. This causes:

1. **Reference breakage**: A fillet on "Face #0" now fillets the wrong face
2. **Operation failures**: References to deleted/split faces crash the kernel
3. **Unpredictable behavior**: Changing early features breaks later features

### The Solution

Implement **Persistent Naming** that tracks the *genealogy* of geometry:

- Instead of "Face #0", track "The face generated by `Extrude-1`, from `LineSegment-A` in `Sketch-1`"
- When topology regenerates, resolve references by tracing lineage, not by index
- Use geometric heuristics as fallback when exact matches fail

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           TOPOLOGICAL NAMING ENGINE                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────────────┐    ┌───────────────────┐    ┌──────────────────────┐  │
│  │  Stable ID       │    │  Topology         │    │  Reference           │  │
│  │  Generator       │───▶│  Graph            │───▶│  Resolver            │  │
│  │                  │    │                   │    │                      │  │
│  │ • UUID Gen       │    │ • Parent-Child    │    │ • Exact Match        │  │
│  │ • Sketch Entity  │    │ • Generator Links │    │ • Fuzzy Heuristics   │  │
│  │   Tagging        │    │ • History Tracking│    │ • User Prompts       │  │
│  └──────────────────┘    └───────────────────┘    └──────────────────────┘  │
│           │                        │                        │               │
│           ▼                        ▼                        ▼               │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │                        TOPOLOGY TRACKER                                  ││
│  │  • Records all topology changes during operations                       ││
│  │  • Maintains mapping: StableID → (OperationID, SourceEntity, Result)    ││
│  │  • Serializable for project save/load                                   ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│                                      │                                      │
│                                      ▼                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │                        OCCT SHAPE ANALYZER                               ││
│  │  • Wraps OpenCascade geometry introspection                             ││
│  │  • Extracts face normals, centroids, edge curves, vertex positions      ││
│  │  • Computes geometric signatures for heuristic matching                 ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Data Structures

### 1. StableTopologyId

A unique, persistent identifier for any topological entity.

```typescript
// src/lib/topology/StableId.ts

/**
 * Stable identifier for a topological entity (face, edge, vertex).
 * Persisted across regenerations.
 */
export interface StableTopologyId {
  /** UUID - globally unique across all time */
  uuid: string;
  
  /** Human-readable label for debugging (e.g., "Extrude1_TopFace") */
  label?: string;
  
  /** Type of entity */
  entityType: 'face' | 'edge' | 'vertex';
  
  /** The operation that created this entity */
  sourceOperationId: string;
  
  /** Link to the source geometry that generated this entity */
  generatorLinks: GeneratorLink[];
  
  /** Geometric signature for heuristic matching */
  geometricSignature?: GeometricSignature;
}

/**
 * Link to a source entity that generated this topology.
 * For example, an extruded face is generated from a sketch edge.
 */
export interface GeneratorLink {
  /** Type of relationship */
  type: 'extruded_from' | 'revolved_from' | 'split_from' | 'fused_with' | 'cut_by' | 'fillet_of' | 'chamfer_of';
  
  /** StableId of the source entity (e.g., sketch line UUID) */
  sourceEntityId: string;
  
  /** Additional semantic info */
  semanticTag?: 'top' | 'bottom' | 'side' | 'lateral' | 'end_cap';
}

/**
 * Geometric signature for fuzzy matching when exact IDs fail.
 */
export interface GeometricSignature {
  /** Centroid position (for faces and edges) */
  centroid?: [number, number, number];
  
  /** Normal vector (for faces) */
  normal?: [number, number, number];
  
  /** Axis direction (for cylindrical/conical faces or linear edges) */
  axisDirection?: [number, number, number];
  
  /** Surface area (for faces) */
  area?: number;
  
  /** Length (for edges) */
  length?: number;
  
  /** Surface type (plane, cylinder, cone, sphere, torus, nurbs) */
  surfaceType?: string;
  
  /** Curve type (line, circle, ellipse, spline) */
  curveType?: string;
  
  /** Bounding box */
  boundingBox?: {
    min: [number, number, number];
    max: [number, number, number];
  };
}
```

### 2. TopologyGraph

Maintains the parent-child relationships and history of topology.

```typescript
// src/lib/topology/TopologyGraph.ts

/**
 * Represents the full topology evolution graph.
 * Tracks how topology entities are created, modified, and related.
 */
export interface TopologyGraph {
  /** Map of StableId UUID to TopologyNode */
  nodes: Map<string, TopologyNode>;
  
  /** Operation history (ordered list of operation IDs) */
  operationHistory: string[];
  
  /** Snapshot of topology state after each operation */
  operationSnapshots: Map<string, TopologySnapshot>;
}

export interface TopologyNode {
  id: StableTopologyId;
  
  /** Current transient index in the shape (for display) */
  currentIndex?: number;
  
  /** Is this entity currently alive (not deleted)? */
  isAlive: boolean;
  
  /** Parent entities (what this was derived from) */
  parentIds: string[];
  
  /** Child entities (what was derived from this) */
  childIds: string[];
  
  /** Last operation that modified this entity */
  lastModifiedBy?: string;
}

export interface TopologySnapshot {
  /** Operation ID this snapshot is for */
  operationId: string;
  
  /** Map of StableId UUID to transient index at this point in history */
  indexMap: Map<string, number>;
  
  /** Set of alive entity UUIDs */
  aliveEntities: Set<string>;
}
```

### 3. TopologyReference (Enhanced)

Replacing the existing index-based reference.

```typescript
// src/lib/topology/TopologyReference.ts

/**
 * A reference to a topological entity that can be resolved across regenerations.
 */
export interface TopologyReference {
  /** Type of topological element */
  type: 'face' | 'edge' | 'vertex';
  
  /** The ID of the base solid/body object (AST variable name) */
  baseObjectId: string;
  
  /** Primary: Stable ID (persisted) */
  stableId?: string;
  
  /** Fallback: Display-time index (transient, used for initial pick) */
  indexHint?: number;
  
  /** Semantic selector (e.g., "top", "bottom", "largest") */
  semanticSelector?: SemanticSelector;
  
  /** Geometric selector for fuzzy matching */
  geometricSelector?: GeometricSelector;
}

export interface SemanticSelector {
  type: 'topmost' | 'bottommost' | 'largest' | 'smallest' | 
        'parallel_to_plane' | 'perpendicular_to_axis' | 'at_position';
  params?: Record<string, any>;
}

export interface GeometricSelector {
  /** Match by normal direction (within tolerance) */
  normalDirection?: [number, number, number];
  normalTolerance?: number;
  
  /** Match by centroid position (within tolerance) */
  centroidPosition?: [number, number, number];
  positionTolerance?: number;
  
  /** Match by area range */
  areaRange?: { min?: number; max?: number };
}
```

---

## Implementation Phases

### Phase 1: Foundation ✅ COMPLETE

**Goal**: Create the core data structures and ID generation system.

**Implementation Notes**: 
Phase 1 has been fully implemented with the following modules:

#### Files Created:

1. **`src/lib/topology/StableId.ts`** ✅
   - `StableTopologyId` interface with UUID, entity type, generator links, geometric signature
   - `GeneratorLink` interface for tracking how entities are created
   - `GeometricSignature` interface for fuzzy matching (centroid, normal, area, etc.)
   - Factory functions: `createStableId`, `createPrimitiveFaceId`, `createExtrudedFaceId`, `createFilletFaceId`
   - Serialization/deserialization utilities
   - `signaturesMatch` for comparing geometric signatures

2. **`src/lib/topology/TopologyGraph.ts`** ✅
   - `TopologyGraph` class with full CRUD operations
   - `TopologyNode` for tracking entity state and relationships
   - Parent-child relationship tracking
   - Operation history with snapshots for undo/redo
   - Indexing by feature and entity type
   - Serialization/deserialization for project persistence

3. **`src/lib/topology/TopologyReference.ts`** ✅
   - Enhanced `TopologyReference` with stable IDs, semantic selectors, geometric selectors
   - `SemanticSelector` types: topmost, bottommost, largest, smallest, parallel_to_plane, etc.
   - `GeometricSelector` for fuzzy matching by position, normal, area, etc.
   - Factory functions for common references (top face, bottom face, largest face)
   - Legacy compatibility with `parseSelectionId` and `toSelectionId`

4. **`src/lib/topology/TopologyTracker.ts`** ✅
   - Singleton service for tracking all topology changes
   - Operation context management (beginOperation/endOperation)
   - Entity registration (registerFace, registerEdge, registerVertex)
   - Index-to-UUID and UUID-to-index mappings
   - Regeneration handling with geometric matching
   - Change listeners for UI updates
   - Full serialization/deserialization

5. **`src/lib/topology/ReferenceResolver.ts`** ✅
   - Multi-strategy resolution: stableId → semantic → geometric → indexHint
   - Confidence scoring for each resolution
   - Caching of resolution results
   - Alternative candidates for uncertain matches
   - Full semantic selector resolution (topmost, bottommost, largest, etc.)
   - Geometric scoring algorithm

6. **`src/lib/topology/ShapeAnalyzer.ts`** ✅
   - Wraps Replicad/OpenCascade shapes
   - Extracts face signatures (centroid, normal, area, surface type)
   - Extracts edge signatures (centroid, length, curve type, direction)
   - Extracts vertex positions
   - Semantic analysis: findTopmostFace, findLargestFace, findFacesParallelTo
   - Full topology analysis for TopologyTracker

7. **`src/lib/topology/index.ts`** ✅ (Updated)
   - Re-exports all new types and functions
   - Maintains backward compatibility with legacy interfaces

8. **`src/lib/topology/topology.test.ts`** ✅
   - 52 comprehensive unit tests
   - Tests for all major components and edge cases

#### Dependencies Added:
- `uuid` package for generating UUIDs
- `@types/uuid` for TypeScript types

---

### Phase 2: Sketch Entity Tagging ✅ COMPLETE

**Goal**: Assign stable IDs to all sketch primitives.

**Implementation Notes**:
Phase 2 has been fully implemented with the following modules:

#### Files Created:

1. **`src/lib/topology/SketchTopologyBridge.ts`** ✅
   - `TaggedSketchPrimitive` interface extending SketchPrimitive with `stableId`
   - `SketchTopologyRegistry` for tracking primitives in a sketch
   - `tagPrimitive` and `tagAllPrimitives` functions for assigning stable IDs
   - `hashPoint` and `getPointStableId` for point deduplication
   - Registry management: `createSketchRegistry`, `getSketchRegistry`, `registerPrimitive`
   - Generator link creation: `createExtrusionGeneratorLinks`, `createRevolutionGeneratorLinks`, etc.
   - `createExtrusionMapping` for mapping sketch edges to solid faces
   - Full serialization/deserialization support
   - `registerSketchWithTracker` for integration with TopologyTracker

---

### Phase 3: Operation Instrumentation ✅ COMPLETE

**Goal**: Record topology creation during operations.

**Implementation Notes**:
Phase 3 has been fully implemented with the following operation analyzers:

#### Files Created:

1. **`src/lib/topology/operations/ExtrusionAnalyzer.ts`** ✅
   - `ExtrusionAnalyzer` class for analyzing extrusion results
   - Identifies top/bottom caps by normal alignment
   - Maps side faces to source sketch edges
   - Creates stable IDs with proper generator links
   - `analyzeExtrusion` factory function
   - `registerExtrusionWithTracker` for global registration

2. **`src/lib/topology/operations/PrimitiveAnalyzer.ts`** ✅
   - `PrimitiveAnalyzer` class for box, cylinder, sphere, cone, torus
   - Semantic face classification (top, bottom, left, right, front, back, lateral, top_cap, bottom_cap, outer)
   - `PrimitiveFaceSemantics` type for face labels
   - `analyzePrimitive` factory function
   - `registerPrimitiveWithTracker` for global registration

3. **`src/lib/topology/operations/BooleanAnalyzer.ts`** ✅
   - `BooleanAnalyzer` class for fuse, cut, intersect operations
   - Face provenance tracking (target, tool, generated origins)
   - Pre-operation face capture with `captureFaceInfo`
   - Geometric matching to track faces through boolean operations
   - Statistics: facesFromTarget, facesFromTool, generatedFaces
   - `analyzeBoolean` factory function
   - `registerBooleanWithTracker` for global registration

4. **`src/lib/topology/operations/FilletAnalyzer.ts`** ✅
   - `FilletAnalyzer` class for fillet and chamfer operations
   - Identifies new fillet surfaces (cylindrical/toroidal)
   - Tracks modified vs unchanged faces
   - Pre-operation capture with `captureEdgeInfo` and `captureFaceInfoForFillet`
   - `analyzeFillet` factory function
   - `registerFilletWithTracker` for global registration

5. **`src/lib/topology/operations/index.ts`** ✅
   - Re-exports all operation analyzers

6. **`src/lib/topology/index.ts`** ✅ (Updated)
   - Added exports for SketchTopologyBridge
   - Added exports for all operation analyzers
   - Extended `SemanticTag` type with additional values

---

### Phase 4: Worker Integration (Week 4-5)

**Goal**: Resolve TopologyReferences to current geometry.

#### Files to Create:

1. **`src/lib/topology/ReferenceResolver.ts`**
   ```typescript
   export class ReferenceResolver {
     /**
      * Resolve a reference to a current face/edge/vertex index.
      * Returns null if unresolvable (prompts user in that case).
      */
     resolve(
       ref: TopologyReference,
       currentTopology: TopologyGraph,
       shape: any
     ): { index: number; confidence: number } | null;
     
     /**
      * Strategy 1: Exact StableId match
      */
     private resolveByStableId(ref: TopologyReference): number | null;
     
     /**
      * Strategy 2: Semantic selector (e.g., "top face")
      */
     private resolveBySemanticSelector(ref: TopologyReference, shape: any): number | null;
     
     /**
      * Strategy 3: Geometric heuristics (position, normal, area)
      */
     private resolveByGeometry(ref: TopologyReference, shape: any): { index: number; confidence: number } | null;
   }
   ```

2. **`src/lib/topology/GeometricMatcher.ts`**
   - Implements fuzzy matching algorithms
   - Computes similarity scores between GeometricSignatures
   - Handles degenerate cases (multiple matches, no matches)

---

### Phase 5: User Interface (Week 5-6)

**Goal**: Handle unresolvable references gracefully.

#### Features:

1. **Broken Reference Indicators**
   - Visual highlight on features with broken references
   - Error message in feature tree

2. **Reference Repair Dialog**
   - When reference cannot be resolved:
     - Show candidates with confidence scores
     - Allow user to select the correct entity
     - Option to use geometric selector going forward

3. **Reference Migration Tool**
   - Batch repair for projects with legacy index-based refs
   - Automatic geometric selector generation

---

### Phase 6: Code Manager Integration (Week 6-7)

**Goal**: Generate code with stable references.

#### Current Code Generation:
```javascript
const shape1 = replicad.makeBox(10, 10, 10);
const shape2 = shape1.fillet(1, (e) => e.inDirection([0, 0, 1]));
```

#### New Code Generation:
```javascript
const shape1 = replicad.makeBox(10, 10, 10);
// Reference by StableId with fallback selector
const shape2 = shape1.fillet(1, (e) => selectEdge(shape1, {
  stableId: "edge-uuid-12345",
  fallback: { type: "inDirection", params: [0, 0, 1] }
}));
```

---

## Integration with Worker

The worker needs to be enhanced to:

1. **Receive StableId assignments** from the main thread
2. **Compute GeometricSignatures** for all entities
3. **Return updated mappings** after operations

### Worker Message Types:

```typescript
// New message types for topology

interface TopologyRequestMessage {
  type: 'COMPUTE_TOPOLOGY';
  shapeId: string;
  requestSignatures: boolean;
}

interface TopologyResponseMessage {
  type: 'TOPOLOGY_RESULT';
  shapeId: string;
  faces: Array<{
    index: number;
    signature: GeometricSignature;
  }>;
  edges: Array<{
    index: number;
    signature: GeometricSignature;
  }>;
  vertices: Array<{
    index: number;
    position: [number, number, number];
  }>;
}
```

---

## Database Schema Updates

For project persistence, we need to store topology information.

### New Fields in Project Data:

```typescript
interface ProjectData {
  // Existing
  code: string;
  
  // NEW: Topology tracking
  topology: {
    graph: SerializedTopologyGraph;
    sketchStableIds: Map<string, Map<string, string>>; // sketchId -> primitiveId -> stableId
    currentReferences: TopologyReference[];
  };
}
```

---

## Testing Strategy

### Unit Tests:

1. **StableId generation** - Uniqueness, serialization
2. **TopologyGraph CRUD** - Add, remove, query nodes
3. **ReferenceResolver** - Each resolution strategy
4. **GeometricMatcher** - Similarity scoring, edge cases

### Integration Tests:

1. **Extrude then modify sketch** - Verify references survive
2. **Insert operation in history** - Verify downstream refs update
3. **Boolean operations** - Verify face tracking through fuse/cut

### E2E Tests:

1. **User workflow**: Create box → Fillet edge → Change box size → Fillet still on same edge
2. **Complex model**: Build multi-feature model, modify early feature, verify all refs

---

## Migration Path

For existing projects:

1. **On load**: Detect legacy index-based references
2. **Auto-generate**: Create StableIds for current topology state
3. **Best-effort mapping**: Use geometric matching to associate refs with StableIds
4. **User review**: Flag low-confidence mappings for manual review

---

## Risk Mitigation

### Risk 1: OpenCascade Topology Changes

OCCT can renumber topology in unpredictable ways. Mitigation:
- Heavy reliance on geometric signatures
- Multiple fallback strategies
- User intervention as last resort

### Risk 2: Performance

Computing signatures for all entities is expensive. Mitigation:
- Lazy signature computation (only when needed for resolution)
- Cache signatures between regenerations
- Incremental updates when possible

### Risk 3: Serialization Size

Storing full topology graph could bloat projects. Mitigation:
- Prune dead nodes periodically
- Compress signature data
- Store signatures only for referenced entities

---

## Success Metrics

1. **Reference Stability**: 95%+ of references survive single-feature modifications
2. **Resolution Time**: <100ms for reference resolution on complex models
3. **User Friction**: <5% of operations require manual reference repair
4. **Project Size**: <20% increase in project file size

---

## Next Steps

1. **Approve this plan** and refine any unclear areas
2. **Begin Phase 1** implementation with core data structures
3. **Create test fixtures** for validation
4. **Iterate** based on real-world testing

---

## Appendix: OpenCascade Topology Primer

### Face Identification in OCCT

OCCT uses a `TopoDS_Shape` hierarchy:
- `TopoDS_Compound` → `TopoDS_Solid` → `TopoDS_Shell` → `TopoDS_Face` → `TopoDS_Wire` → `TopoDS_Edge` → `TopoDS_Vertex`

Each face has:
- A **surface definition** (plane, cylinder, etc.)
- **Wire boundaries** (outer wire + inner wires for holes)
- **Edge curves** (line, circle, spline, etc.)

### Replicad API

Replicad exposes:
- `shape.faces` → iterator of Face wrappers
- `face.normalAt(point)` → normal vector
- `face.center` → centroid
- `face.outerWire()` → boundary wire
- `shape.edges` → iterator of Edge wrappers
- `edge.length` → curve length

These APIs are sufficient for computing GeometricSignatures.

---

## Appendix: Similar Implementations

### FreeCAD TNP (Topological Naming Problem) Solution

FreeCAD implemented a solution in 2022-2023:
- Uses "mapped names" that encode geometry derivation
- Format: `Face1;:G;EXT;:H33:7,F;:H34:7,F;:H35:7,F;FLT;:H36:7,E`
- Stores in shape attributes

### Onshape

Uses a combination of:
- Deterministic naming based on operation sequence
- Geometric heuristics for robustness
- User-selectable "stable reference" mode

### Fusion 360

Similar to Onshape, with additional:
- "Body tracking" through history
- Explicit reference repair UI

---

*Document Version: 1.0*
*Author: HiveCAD Architecture Team*
*Date: 2026-02-07*

# Topological Naming Engine - Implementation Plan

## Executive Summary

This document outlines the architecture and implementation plan for a **Persistent Topological Naming System** in HiveCAD. This is the critical missing piece that prevents HiveCAD from achieving Onshape/Fusion 360-level parametric modeling robustness.

### The Problem

Currently, HiveCAD references geometry by **transient index** (e.g., `shape1:face-0`). When the model history changes (adding/removing features, modifying sketches), the topology regenerates with potentially different indices. This causes:

1. **Reference breakage**: A fillet on "Face #0" now fillets the wrong face
2. **Operation failures**: References to deleted/split faces crash the kernel
3. **Unpredictable behavior**: Changing early features breaks later features

### The Solution

Implement **Persistent Naming** that tracks the *genealogy* of geometry:

- Instead of "Face #0", track "The face generated by `Extrude-1`, from `LineSegment-A` in `Sketch-1`"
- When topology regenerates, resolve references by tracing lineage, not by index
- Use geometric heuristics as fallback when exact matches fail

---

## Implementation Status

| Phase | Description | Status |
|-------|-------------|--------|
| 1 | Foundation (Core Data Structures) | ✅ Complete |
| 2 | Sketch Entity Tagging | ✅ Complete |
| 3 | Operation Instrumentation | ✅ Complete |
| 4 | Worker Integration | ✅ Complete |
| 5 | User Interface | ✅ Complete |
| 6 | Code Manager Integration | ✅ Complete |
| 7 | Testing & Validation | ✅ Complete |

---

## Architecture Overview


```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           TOPOLOGICAL NAMING ENGINE                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────────────┐    ┌───────────────────┐    ┌──────────────────────┐  │
│  │  Stable ID       │    │  Topology         │    │  Reference           │  │
│  │  Generator       │───▶│  Graph            │───▶│  Resolver            │  │
│  │                  │    │                   │    │                      │  │
│  │ • UUID Gen       │    │ • Parent-Child    │    │ • Exact Match        │  │
│  │ • Sketch Entity  │    │ • Generator Links │    │ • Fuzzy Heuristics   │  │
│  │   Tagging        │    │ • History Tracking│    │ • User Prompts       │  │
│  └──────────────────┘    └───────────────────┘    └──────────────────────┘  │
│           │                        │                        │               │
│           ▼                        ▼                        ▼               │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │                        TOPOLOGY TRACKER                                  ││
│  │  • Records all topology changes during operations                       ││
│  │  • Maintains mapping: StableID → (OperationID, SourceEntity, Result)    ││
│  │  • Serializable for project save/load                                   ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│                                      │                                      │
│                                      ▼                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │                        OCCT SHAPE ANALYZER                               ││
│  │  • Wraps OpenCascade geometry introspection                             ││
│  │  • Extracts face normals, centroids, edge curves, vertex positions      ││
│  │  • Computes geometric signatures for heuristic matching                 ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Data Structures

### 1. StableTopologyId

A unique, persistent identifier for any topological entity.

```typescript
// src/lib/topology/StableId.ts

/**
 * Stable identifier for a topological entity (face, edge, vertex).
 * Persisted across regenerations.
 */
export interface StableTopologyId {
  /** UUID - globally unique across all time */
  uuid: string;
  
  /** Human-readable label for debugging (e.g., "Extrude1_TopFace") */
  label?: string;
  
  /** Type of entity */
  entityType: 'face' | 'edge' | 'vertex';
  
  /** The operation that created this entity */
  sourceOperationId: string;
  
  /** Link to the source geometry that generated this entity */
  generatorLinks: GeneratorLink[];
  
  /** Geometric signature for heuristic matching */
  geometricSignature?: GeometricSignature;
}

/**
 * Link to a source entity that generated this topology.
 * For example, an extruded face is generated from a sketch edge.
 */
export interface GeneratorLink {
  /** Type of relationship */
  type: 'extruded_from' | 'revolved_from' | 'split_from' | 'fused_with' | 'cut_by' | 'fillet_of' | 'chamfer_of';
  
  /** StableId of the source entity (e.g., sketch line UUID) */
  sourceEntityId: string;
  
  /** Additional semantic info */
  semanticTag?: 'top' | 'bottom' | 'side' | 'lateral' | 'end_cap';
}

/**
 * Geometric signature for fuzzy matching when exact IDs fail.
 */
export interface GeometricSignature {
  /** Centroid position (for faces and edges) */
  centroid?: [number, number, number];
  
  /** Normal vector (for faces) */
  normal?: [number, number, number];
  
  /** Axis direction (for cylindrical/conical faces or linear edges) */
  axisDirection?: [number, number, number];
  
  /** Surface area (for faces) */
  area?: number;
  
  /** Length (for edges) */
  length?: number;
  
  /** Surface type (plane, cylinder, cone, sphere, torus, nurbs) */
  surfaceType?: string;
  
  /** Curve type (line, circle, ellipse, spline) */
  curveType?: string;
  
  /** Bounding box */
  boundingBox?: {
    min: [number, number, number];
    max: [number, number, number];
  };
}
```

### 2. TopologyGraph

Maintains the parent-child relationships and history of topology.

```typescript
// src/lib/topology/TopologyGraph.ts

/**
 * Represents the full topology evolution graph.
 * Tracks how topology entities are created, modified, and related.
 */
export interface TopologyGraph {
  /** Map of StableId UUID to TopologyNode */
  nodes: Map<string, TopologyNode>;
  
  /** Operation history (ordered list of operation IDs) */
  operationHistory: string[];
  
  /** Snapshot of topology state after each operation */
  operationSnapshots: Map<string, TopologySnapshot>;
}

export interface TopologyNode {
  id: StableTopologyId;
  
  /** Current transient index in the shape (for display) */
  currentIndex?: number;
  
  /** Is this entity currently alive (not deleted)? */
  isAlive: boolean;
  
  /** Parent entities (what this was derived from) */
  parentIds: string[];
  
  /** Child entities (what was derived from this) */
  childIds: string[];
  
  /** Last operation that modified this entity */
  lastModifiedBy?: string;
}

export interface TopologySnapshot {
  /** Operation ID this snapshot is for */
  operationId: string;
  
  /** Map of StableId UUID to transient index at this point in history */
  indexMap: Map<string, number>;
  
  /** Set of alive entity UUIDs */
  aliveEntities: Set<string>;
}
```

### 3. TopologyReference (Enhanced)

Replacing the existing index-based reference.

```typescript
// src/lib/topology/TopologyReference.ts

/**
 * A reference to a topological entity that can be resolved across regenerations.
 */
export interface TopologyReference {
  /** Type of topological element */
  type: 'face' | 'edge' | 'vertex';
  
  /** The ID of the base solid/body object (AST variable name) */
  baseObjectId: string;
  
  /** Primary: Stable ID (persisted) */
  stableId?: string;
  
  /** Fallback: Display-time index (transient, used for initial pick) */
  indexHint?: number;
  
  /** Semantic selector (e.g., "top", "bottom", "largest") */
  semanticSelector?: SemanticSelector;
  
  /** Geometric selector for fuzzy matching */
  geometricSelector?: GeometricSelector;
}

export interface SemanticSelector {
  type: 'topmost' | 'bottommost' | 'largest' | 'smallest' | 
        'parallel_to_plane' | 'perpendicular_to_axis' | 'at_position';
  params?: Record<string, any>;
}

export interface GeometricSelector {
  /** Match by normal direction (within tolerance) */
  normalDirection?: [number, number, number];
  normalTolerance?: number;
  
  /** Match by centroid position (within tolerance) */
  centroidPosition?: [number, number, number];
  positionTolerance?: number;
  
  /** Match by area range */
  areaRange?: { min?: number; max?: number };
}
```

---

## Implementation Phases

### Phase 1: Foundation ✅ COMPLETE

**Goal**: Create the core data structures and ID generation system.

**Implementation Notes**: 
Phase 1 has been fully implemented with the following modules:

#### Files Created:

1. **`src/lib/topology/StableId.ts`** ✅
   - `StableTopologyId` interface with UUID, entity type, generator links, geometric signature
   - `GeneratorLink` interface for tracking how entities are created
   - `GeometricSignature` interface for fuzzy matching (centroid, normal, area, etc.)
   - Factory functions: `createStableId`, `createPrimitiveFaceId`, `createExtrudedFaceId`, `createFilletFaceId`
   - Serialization/deserialization utilities
   - `signaturesMatch` for comparing geometric signatures

2. **`src/lib/topology/TopologyGraph.ts`** ✅
   - `TopologyGraph` class with full CRUD operations
   - `TopologyNode` for tracking entity state and relationships
   - Parent-child relationship tracking
   - Operation history with snapshots for undo/redo
   - Indexing by feature and entity type
   - Serialization/deserialization for project persistence

3. **`src/lib/topology/TopologyReference.ts`** ✅
   - Enhanced `TopologyReference` with stable IDs, semantic selectors, geometric selectors
   - `SemanticSelector` types: topmost, bottommost, largest, smallest, parallel_to_plane, etc.
   - `GeometricSelector` for fuzzy matching by position, normal, area, etc.
   - Factory functions for common references (top face, bottom face, largest face)
   - Legacy compatibility with `parseSelectionId` and `toSelectionId`

4. **`src/lib/topology/TopologyTracker.ts`** ✅
   - Singleton service for tracking all topology changes
   - Operation context management (beginOperation/endOperation)
   - Entity registration (registerFace, registerEdge, registerVertex)
   - Index-to-UUID and UUID-to-index mappings
   - Regeneration handling with geometric matching
   - Change listeners for UI updates
   - Full serialization/deserialization

5. **`src/lib/topology/ReferenceResolver.ts`** ✅
   - Multi-strategy resolution: stableId → semantic → geometric → indexHint
   - Confidence scoring for each resolution
   - Caching of resolution results
   - Alternative candidates for uncertain matches
   - Full semantic selector resolution (topmost, bottommost, largest, etc.)
   - Geometric scoring algorithm

6. **`src/lib/topology/ShapeAnalyzer.ts`** ✅
   - Wraps Replicad/OpenCascade shapes
   - Extracts face signatures (centroid, normal, area, surface type)
   - Extracts edge signatures (centroid, length, curve type, direction)
   - Extracts vertex positions
   - Semantic analysis: findTopmostFace, findLargestFace, findFacesParallelTo
   - Full topology analysis for TopologyTracker

7. **`src/lib/topology/index.ts`** ✅ (Updated)
   - Re-exports all new types and functions
   - Maintains backward compatibility with legacy interfaces

8. **`src/lib/topology/topology.test.ts`** ✅
   - 52 comprehensive unit tests
   - Tests for all major components and edge cases

#### Dependencies Added:
- `uuid` package for generating UUIDs
- `@types/uuid` for TypeScript types

---

### Phase 2: Sketch Entity Tagging ✅ COMPLETE

**Goal**: Assign stable IDs to all sketch primitives.

**Implementation Notes**:
Phase 2 has been fully implemented with the following modules:

#### Files Created:

1. **`src/lib/topology/SketchTopologyBridge.ts`** ✅
   - `TaggedSketchPrimitive` interface extending SketchPrimitive with `stableId`
   - `SketchTopologyRegistry` for tracking primitives in a sketch
   - `tagPrimitive` and `tagAllPrimitives` functions for assigning stable IDs
   - `hashPoint` and `getPointStableId` for point deduplication
   - Registry management: `createSketchRegistry`, `getSketchRegistry`, `registerPrimitive`
   - Generator link creation: `createExtrusionGeneratorLinks`, `createRevolutionGeneratorLinks`, etc.
   - `createExtrusionMapping` for mapping sketch edges to solid faces
   - Full serialization/deserialization support
   - `registerSketchWithTracker` for integration with TopologyTracker

---

### Phase 3: Operation Instrumentation ✅ COMPLETE

**Goal**: Record topology creation during operations.

**Implementation Notes**:
Phase 3 has been fully implemented with the following operation analyzers:

#### Files Created:

1. **`src/lib/topology/operations/ExtrusionAnalyzer.ts`** ✅
   - `ExtrusionAnalyzer` class for analyzing extrusion results
   - Identifies top/bottom caps by normal alignment
   - Maps side faces to source sketch edges
   - Creates stable IDs with proper generator links
   - `analyzeExtrusion` factory function
   - `registerExtrusionWithTracker` for global registration

2. **`src/lib/topology/operations/PrimitiveAnalyzer.ts`** ✅
   - `PrimitiveAnalyzer` class for box, cylinder, sphere, cone, torus
   - Semantic face classification (top, bottom, left, right, front, back, lateral, top_cap, bottom_cap, outer)
   - `PrimitiveFaceSemantics` type for face labels
   - `analyzePrimitive` factory function
   - `registerPrimitiveWithTracker` for global registration

3. **`src/lib/topology/operations/BooleanAnalyzer.ts`** ✅
   - `BooleanAnalyzer` class for fuse, cut, intersect operations
   - Face provenance tracking (target, tool, generated origins)
   - Pre-operation face capture with `captureFaceInfo`
   - Geometric matching to track faces through boolean operations
   - Statistics: facesFromTarget, facesFromTool, generatedFaces
   - `analyzeBoolean` factory function
   - `registerBooleanWithTracker` for global registration

4. **`src/lib/topology/operations/FilletAnalyzer.ts`** ✅
   - `FilletAnalyzer` class for fillet and chamfer operations
   - Identifies new fillet surfaces (cylindrical/toroidal)
   - Tracks modified vs unchanged faces
   - Pre-operation capture with `captureEdgeInfo` and `captureFaceInfoForFillet`
   - `analyzeFillet` factory function
   - `registerFilletWithTracker` for global registration

5. **`src/lib/topology/operations/index.ts`** ✅
   - Re-exports all operation analyzers

6. **`src/lib/topology/index.ts`** ✅ (Updated)
   - Added exports for SketchTopologyBridge
   - Added exports for all operation analyzers
   - Extended `SemanticTag` type with additional values

---

### Phase 4: Worker Integration (Week 4-5)

**Goal**: Resolve TopologyReferences to current geometry.

**Implementation Notes**:
Phase 4 has been fully implemented with the following modules:

#### Files Created:

1. **`src/lib/topology/WorkerTopologyBridge.ts`** ✅
   - `SerializedTopologyData` interface for worker-to-main-thread communication
   - `TopologyEnhancedMeshResult` for mesh data with topology
   - `ObjectTopologyState` for storing topology in CADObjects
   - `extractFaceSignature` and `extractEdgeSignature` for worker-side extraction
   - `generateTopologyForShape` for creating topology data in worker
   - `reconstructTopologyId` and `reconstructTopologyData` for main-thread parsing
   - `buildTopologyState` and `createEmptyTopologyState` utilities
   - Full serialization/deserialization for persistence

---

### Phase 5: User Interface ✅ COMPLETE

**Goal**: Handle unresolvable references gracefully.

**Implementation Notes**:
Phase 5 has been fully implemented with the following modules:

#### Files Created:

1. **`src/lib/topology/ReferenceManager.ts`** ✅
   - `ReferenceStatus` type: valid, warning, broken, pending, migrated
   - `ReferenceState` interface for tracking reference status
   - `ReferenceEvent` types for status changes and repairs
   - `ReferenceManager` singleton class for global reference tracking
   - Methods for registering, updating, and repairing references
   - Feature-level and global status queries
   - Event listener system for UI updates

2. **`src/components/cad/ReferenceIndicator.tsx`** ✅
   - Color-coded status indicator (green/yellow/red)
   - Tooltip with status description
   - Click handler for opening repair dialog
   - Size variants (sm, md, lg)

3. **`src/components/cad/ReferenceRepairDialog.tsx`** ✅
   - Modal for repairing broken references
   - Shows candidates with confidence scores
   - Accept best match or select manually
   - Highlights entities in viewport
   - Skip functionality for unresolvable references

4. **`src/hooks/useReferenceStatus.ts`** ✅
   - `useFeatureReferenceStatus` hook for feature-level status
   - `useGlobalReferenceStatus` hook for application-wide status
   - `useReferenceEvents` hook for subscribing to changes

---

### Phase 6: Code Manager Integration ✅ COMPLETE

**Goal**: Generate code with stable references.

**Implementation Notes**:
Phase 6 has been fully implemented with the following modules:

#### Files Created:

1. **`src/lib/topology/CodeGeneration.ts`** ✅
   - `ReferenceCodeOptions` for configuring code output
   - `ReferenceCodeGenerator` class with methods:
     - `generateReferenceCode` for any TopologyReference
     - `generateFaceSelector` and `generateEdgeSelector`
     - `generateSemanticSelector` and `generateGeometricSelector`
     - `generateFilletCode`, `generateChamferCode`, `generateFaceExtrusionCode`
   - Factory function: `createReferenceCodeGenerator`
   - Quick helpers: `generateFaceSelectionCode`, `generateEdgeSelectionCode`
   - Migration utilities:
     - `transformIndexToStableReference` for upgrading legacy code
     - `extractIndexReferences` for finding index-based references
     - `generateMigrationReport` for analyzing code

#### Example Generated Code:

**Before (legacy index-based):**
```javascript
const shape1 = replicad.makeBox(10, 10, 10);
const shape2 = shape1.fillet(1, (e) => e.inDirection([0, 0, 1]));
```

**After (stable references):**
```javascript
const shape1 = replicad.makeBox(10, 10, 10);
const shape2 = shape1.fillet(1, (e) => selectEdge(shape1, {
  stableId: "edge-uuid-12345",
  semantic: { type: "topmost" },
  geometric: { normalDirection: [0, 0, 1] },
  indexHint: 4
}));
```

---

### Phase 7: Testing & Validation ✅ COMPLETE

**Goal**: Comprehensive test coverage for all topology modules.

**Implementation Notes**:
Phase 7 has been fully implemented with comprehensive tests for all new modules.

#### Test Files Created:

1. **`src/lib/topology/topology.test.ts`** (existing) ✅
   - 52 tests covering core topology functionality
   - Tests for StableId generation and serialization
   - Tests for TopologyGraph node management
   - Tests for TopologyReference creation
   - Tests for TopologyTracker operations
   - Tests for ReferenceResolver strategies
   - Tests for ShapeAnalyzer extraction

2. **`src/lib/topology/topology-phase456.test.ts`** ✅
   - 65 tests covering Phases 4, 5, and 6
   - **WorkerTopologyBridge tests**:
     - `extractFaceSignature` extraction
     - `extractEdgeSignature` extraction
     - `generateTopologyForShape` generation
     - `reconstructTopologyId` reconstruction
     - `createEmptyTopologyState` and `buildTopologyState`
     - Serialization and deserialization
   - **ReferenceManager tests**:
     - Singleton behavior and reset
     - Reference registration
     - Status updates (valid, broken, warning)
     - Feature queries and filtering
     - Reference repair
     - Event listeners
   - **CodeGeneration tests**:
     - `ReferenceCodeGenerator` class
     - Face and edge selector generation
     - Semantic and geometric selectors
     - Fillet, chamfer, extrusion code generation
     - Index reference extraction
     - Legacy code transformation
     - Migration reports
   - **Integration tests**:
     - Worker → ReferenceManager flow
     - ReferenceManager → CodeGeneration flow
     - Full pipeline test

#### Test Results:
```
Test Files  2 passed (2)
    Tests  117 passed (117)
```

---

## Integration with Worker

The worker needs to be enhanced to:

1. **Receive StableId assignments** from the main thread
2. **Compute GeometricSignatures** for all entities
3. **Return updated mappings** after operations

### Worker Message Types:

```typescript
// New message types for topology

interface TopologyRequestMessage {
  type: 'COMPUTE_TOPOLOGY';
  shapeId: string;
  requestSignatures: boolean;
}

interface TopologyResponseMessage {
  type: 'TOPOLOGY_RESULT';
  shapeId: string;
  faces: Array<{
    index: number;
    signature: GeometricSignature;
  }>;
  edges: Array<{
    index: number;
    signature: GeometricSignature;
  }>;
  vertices: Array<{
    index: number;
    position: [number, number, number];
  }>;
}
```

---

## Database Schema Updates

For project persistence, we need to store topology information.

### New Fields in Project Data:

```typescript
interface ProjectData {
  // Existing
  code: string;
  
  // NEW: Topology tracking
  topology: {
    graph: SerializedTopologyGraph;
    sketchStableIds: Map<string, Map<string, string>>; // sketchId -> primitiveId -> stableId
    currentReferences: TopologyReference[];
  };
}
```

---

## Testing Strategy

### Unit Tests:

1. **StableId generation** - Uniqueness, serialization
2. **TopologyGraph CRUD** - Add, remove, query nodes
3. **ReferenceResolver** - Each resolution strategy
4. **GeometricMatcher** - Similarity scoring, edge cases

### Integration Tests:

1. **Extrude then modify sketch** - Verify references survive
2. **Insert operation in history** - Verify downstream refs update
3. **Boolean operations** - Verify face tracking through fuse/cut

### E2E Tests:

1. **User workflow**: Create box → Fillet edge → Change box size → Fillet still on same edge
2. **Complex model**: Build multi-feature model, modify early feature, verify all refs

---

## Migration Path

For existing projects:

1. **On load**: Detect legacy index-based references
2. **Auto-generate**: Create StableIds for current topology state
3. **Best-effort mapping**: Use geometric matching to associate refs with StableIds
4. **User review**: Flag low-confidence mappings for manual review

---

## Risk Mitigation

### Risk 1: OpenCascade Topology Changes

OCCT can renumber topology in unpredictable ways. Mitigation:
- Heavy reliance on geometric signatures
- Multiple fallback strategies
- User intervention as last resort

### Risk 2: Performance

Computing signatures for all entities is expensive. Mitigation:
- Lazy signature computation (only when needed for resolution)
- Cache signatures between regenerations
- Incremental updates when possible

### Risk 3: Serialization Size

Storing full topology graph could bloat projects. Mitigation:
- Prune dead nodes periodically
- Compress signature data
- Store signatures only for referenced entities

---

## Success Metrics

1. **Reference Stability**: 95%+ of references survive single-feature modifications
2. **Resolution Time**: <100ms for reference resolution on complex models
3. **User Friction**: <5% of operations require manual reference repair
4. **Project Size**: <20% increase in project file size

---

## Next Steps

1. **Approve this plan** and refine any unclear areas
2. **Begin Phase 1** implementation with core data structures
3. **Create test fixtures** for validation
4. **Iterate** based on real-world testing

---

## Appendix: OpenCascade Topology Primer

### Face Identification in OCCT

OCCT uses a `TopoDS_Shape` hierarchy:
- `TopoDS_Compound` → `TopoDS_Solid` → `TopoDS_Shell` → `TopoDS_Face` → `TopoDS_Wire` → `TopoDS_Edge` → `TopoDS_Vertex`

Each face has:
- A **surface definition** (plane, cylinder, etc.)
- **Wire boundaries** (outer wire + inner wires for holes)
- **Edge curves** (line, circle, spline, etc.)

### Replicad API

Replicad exposes:
- `shape.faces` → iterator of Face wrappers
- `face.normalAt(point)` → normal vector
- `face.center` → centroid
- `face.outerWire()` → boundary wire
- `shape.edges` → iterator of Edge wrappers
- `edge.length` → curve length

These APIs are sufficient for computing GeometricSignatures.

---

## Appendix: Similar Implementations

### FreeCAD TNP (Topological Naming Problem) Solution

FreeCAD implemented a solution in 2022-2023:
- Uses "mapped names" that encode geometry derivation
- Format: `Face1;:G;EXT;:H33:7,F;:H34:7,F;:H35:7,F;FLT;:H36:7,E`
- Stores in shape attributes

### Onshape

Uses a combination of:
- Deterministic naming based on operation sequence
- Geometric heuristics for robustness
- User-selectable "stable reference" mode

### Fusion 360

Similar to Onshape, with additional:
- "Body tracking" through history
- Explicit reference repair UI

---

*Document Version: 1.0*
*Author: HiveCAD Architecture Team*
*Date: 2026-02-07*

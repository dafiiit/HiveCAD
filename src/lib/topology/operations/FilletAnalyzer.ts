/**
 * Fillet/Chamfer Analyzer
 * 
 * Analyzes topology changes from fillet and chamfer operations,
 * tracking which edges were modified and how faces changed.
 * 
 * Phase 3: Operation Instrumentation
 */

import {
    StableTopologyId,
    GeneratorLink,
    GeometricSignature,
    createStableId,
    createFilletFaceId,
    signaturesMatch,
    getTopologyTracker,
} from '../index';
import { ShapeAnalyzer, ReplicadShape } from '../ShapeAnalyzer';
import { TopologyAnalysisResult } from '../TopologyTracker';

// ============================================================================
// Types
// ============================================================================

export type FilletOperationType = 'fillet' | 'chamfer';

/**
 * Fillet operation parameters
 */
export interface FilletParams {
    type: FilletOperationType;

    /** Radius for fillet, distance for chamfer */
    radius: number;

    /** Optional secondary distance for asymmetric chamfer */
    secondaryRadius?: number;

    /** Edges to fillet (by stable ID or index) */
    edgeReferences: Array<{
        stableId?: string;
        featureId: string;
        index: number;
    }>;
}

/**
 * Pre-operation edge info
 */
export interface PreFilletEdgeInfo {
    featureId: string;
    edgeIndex: number;
    stableId?: string;
    signature: GeometricSignature;
    adjacentFaceIndices: number[];
}

/**
 * Pre-operation face info
 */
export interface PreFilletFaceInfo {
    featureId: string;
    faceIndex: number;
    stableId?: string;
    signature: GeometricSignature;
}

/**
 * Analysis result for fillet operation
 */
export interface FilletAnalysisResult {
    /** Faces generated by the fillet (new fillet surfaces) */
    filletFaces: Array<{
        stableId: StableTopologyId;
        faceIndex: number;
        sourceEdgeStableId?: string;
    }>;

    /** Faces that were modified (trimmed by fillet) */
    modifiedFaces: Array<{
        stableId: StableTopologyId;
        faceIndex: number;
        originalStableId?: string;
    }>;

    /** Faces that remained unchanged */
    unchangedFaces: Array<{
        stableId: StableTopologyId;
        faceIndex: number;
        originalStableId?: string;
    }>;

    /** Edges */
    edges: Array<{
        stableId: StableTopologyId;
        edgeIndex: number;
    }>;

    /** Vertices */
    vertices: Array<{
        stableId: StableTopologyId;
        vertexIndex: number;
    }>;

    /** Statistics */
    statistics: {
        filletFaceCount: number;
        modifiedFaceCount: number;
        unchangedFaceCount: number;
    };

    topologyAnalysis: TopologyAnalysisResult;
}

// ============================================================================
// Fillet Analyzer
// ============================================================================

/**
 * Analyzes fillet/chamfer operations
 */
export class FilletAnalyzer {
    private resultShape: ReplicadShape;
    private featureId: string;
    private operationId: string;
    private params: FilletParams;
    private originalEdges: PreFilletEdgeInfo[];
    private originalFaces: PreFilletFaceInfo[];
    private shapeAnalyzer: ShapeAnalyzer;

    constructor(
        resultShape: ReplicadShape,
        featureId: string,
        operationId: string,
        params: FilletParams,
        originalEdges: PreFilletEdgeInfo[],
        originalFaces: PreFilletFaceInfo[]
    ) {
        this.resultShape = resultShape;
        this.featureId = featureId;
        this.operationId = operationId;
        this.params = params;
        this.originalEdges = originalEdges;
        this.originalFaces = originalFaces;
        this.shapeAnalyzer = new ShapeAnalyzer(resultShape, featureId, operationId, params.type);
    }

    /**
     * Analyze the fillet result
     */
    analyze(): FilletAnalysisResult {
        const resultFaces = this.shapeAnalyzer.analyzeFaces();
        const resultEdges = this.shapeAnalyzer.analyzeEdges();
        const resultVertices = this.shapeAnalyzer.analyzeVertices();

        // Classify faces
        const { filletFaces, modifiedFaces, unchangedFaces } = this.classifyFaces(resultFaces);

        return {
            filletFaces,
            modifiedFaces,
            unchangedFaces,
            edges: resultEdges.map((edge, idx) => ({
                stableId: createStableId({
                    entityType: 'edge',
                    sourceOperationId: this.operationId,
                    sourceOperationName: this.params.type,
                    featureId: this.featureId,
                    generatorLinks: [],
                    label: `${this.params.type}_edge_${idx}`,
                    geometricSignature: edge.signature,
                }),
                edgeIndex: edge.index,
            })),
            vertices: resultVertices.map((vertex, idx) => ({
                stableId: createStableId({
                    entityType: 'vertex',
                    sourceOperationId: this.operationId,
                    sourceOperationName: this.params.type,
                    featureId: this.featureId,
                    generatorLinks: [],
                    label: `${this.params.type}_vertex_${idx}`,
                    geometricSignature: { centroid: vertex.position },
                }),
                vertexIndex: vertex.index,
            })),
            statistics: {
                filletFaceCount: filletFaces.length,
                modifiedFaceCount: modifiedFaces.length,
                unchangedFaceCount: unchangedFaces.length,
            },
            topologyAnalysis: this.createTopologyAnalysis(
                filletFaces, modifiedFaces, unchangedFaces, resultEdges, resultVertices
            ),
        };
    }

    /**
     * Classify result faces
     */
    private classifyFaces(
        resultFaces: Array<{ index: number; signature: GeometricSignature }>
    ): {
        filletFaces: Array<{ stableId: StableTopologyId; faceIndex: number; sourceEdgeStableId?: string }>;
        modifiedFaces: Array<{ stableId: StableTopologyId; faceIndex: number; originalStableId?: string }>;
        unchangedFaces: Array<{ stableId: StableTopologyId; faceIndex: number; originalStableId?: string }>;
    } {
        const filletFaces: Array<{ stableId: StableTopologyId; faceIndex: number; sourceEdgeStableId?: string }> = [];
        const modifiedFaces: Array<{ stableId: StableTopologyId; faceIndex: number; originalStableId?: string }> = [];
        const unchangedFaces: Array<{ stableId: StableTopologyId; faceIndex: number; originalStableId?: string }> = [];

        const matchedOriginalFaces = new Set<number>();

        for (const resultFace of resultFaces) {
            // Check if this is a fillet surface (cylindrical/toroidal for fillet, planar for chamfer)
            const isFilletSurface = this.isFilletSurface(resultFace.signature);

            if (isFilletSurface) {
                // Try to find which original edge this fillet came from
                let sourceEdgeStableId: string | undefined;
                for (const edgeRef of this.params.edgeReferences) {
                    // In a real implementation, we'd do geometric matching
                    sourceEdgeStableId = edgeRef.stableId;
                    break;
                }

                filletFaces.push({
                    stableId: createFilletFaceId({
                        featureId: this.featureId,
                        operationId: this.operationId,
                        sourceEdgeId: sourceEdgeStableId || 'unknown',
                        index: filletFaces.length,
                        signature: resultFace.signature,
                    }),
                    faceIndex: resultFace.index,
                    sourceEdgeStableId,
                });
            } else {
                // Try to match to original face
                let bestMatch: { index: number; info: PreFilletFaceInfo; confidence: number } | null = null;

                for (let i = 0; i < this.originalFaces.length; i++) {
                    if (matchedOriginalFaces.has(i)) continue;

                    const matchResult = signaturesMatch(resultFace.signature, this.originalFaces[i].signature);
                    if (matchResult.matches &&
                        (!bestMatch || matchResult.confidence > bestMatch.confidence)) {
                        bestMatch = {
                            index: i,
                            info: this.originalFaces[i],
                            confidence: matchResult.confidence,
                        };
                    }
                }

                if (bestMatch) {
                    matchedOriginalFaces.add(bestMatch.index);

                    // Check if the face was modified (area changed significantly)
                    const areaRatio = (resultFace.signature.area || 0) /
                        (bestMatch.info.signature.area || 1);
                    const isModified = Math.abs(areaRatio - 1) > 0.1;

                    const faceEntry = {
                        stableId: createStableId({
                            entityType: 'face' as const,
                            sourceOperationId: this.operationId,
                            sourceOperationName: this.params.type,
                            featureId: this.featureId,
                            generatorLinks: [{
                                type: 'fillet_of' as const,
                                sourceEntityId: bestMatch.info.stableId || bestMatch.info.featureId,
                                sourceIndex: bestMatch.info.faceIndex,
                                operationId: this.operationId,
                            }],
                            label: isModified ?
                                `${this.params.type}_modified_face_${resultFace.index}` :
                                `${this.params.type}_unchanged_face_${resultFace.index}`,
                            geometricSignature: resultFace.signature,
                        }),
                        faceIndex: resultFace.index,
                        originalStableId: bestMatch.info.stableId,
                    };

                    if (isModified) {
                        modifiedFaces.push(faceEntry);
                    } else {
                        unchangedFaces.push(faceEntry);
                    }
                } else {
                    // No match found - treat as modified
                    modifiedFaces.push({
                        stableId: createStableId({
                            entityType: 'face',
                            sourceOperationId: this.operationId,
                            sourceOperationName: this.params.type,
                            featureId: this.featureId,
                            generatorLinks: [],
                            label: `${this.params.type}_unknown_face_${resultFace.index}`,
                            geometricSignature: resultFace.signature,
                        }),
                        faceIndex: resultFace.index,
                    });
                }
            }
        }

        return { filletFaces, modifiedFaces, unchangedFaces };
    }

    /**
     * Check if a face signature indicates a fillet/chamfer surface
     */
    private isFilletSurface(signature: GeometricSignature): boolean {
        if (this.params.type === 'fillet') {
            // Fillets are typically cylindrical or toroidal
            return signature.surfaceType === 'cylinder' ||
                signature.surfaceType === 'torus' ||
                signature.surfaceType === 'sphere';
        } else {
            // Chamfers are typically planar with specific orientations
            // This is a heuristic - real implementation would need more analysis
            return false;
        }
    }

    /**
     * Create topology analysis
     */
    private createTopologyAnalysis(
        filletFaces: Array<{ stableId: StableTopologyId; faceIndex: number }>,
        modifiedFaces: Array<{ stableId: StableTopologyId; faceIndex: number }>,
        unchangedFaces: Array<{ stableId: StableTopologyId; faceIndex: number }>,
        edges: Array<{ index: number; signature: GeometricSignature }>,
        vertices: Array<{ index: number; position: [number, number, number] }>
    ): TopologyAnalysisResult {
        const allFaces = [
            ...filletFaces,
            ...modifiedFaces,
            ...unchangedFaces,
        ];

        return {
            faces: allFaces.map(f => ({
                index: f.faceIndex,
                signature: f.stableId.geometricSignature || {},
                stableId: f.stableId,
            })),
            edges: edges.map((edge, idx) => ({
                index: edge.index,
                signature: edge.signature,
                stableId: createStableId({
                    entityType: 'edge',
                    sourceOperationId: this.operationId,
                    sourceOperationName: this.params.type,
                    featureId: this.featureId,
                    generatorLinks: [],
                    label: `${this.params.type}_edge_${idx}`,
                    geometricSignature: edge.signature,
                }),
            })),
            vertices: vertices.map((vertex, idx) => ({
                index: vertex.index,
                position: vertex.position,
                stableId: createStableId({
                    entityType: 'vertex',
                    sourceOperationId: this.operationId,
                    sourceOperationName: this.params.type,
                    featureId: this.featureId,
                    generatorLinks: [],
                    label: `${this.params.type}_vertex_${idx}`,
                    geometricSignature: { centroid: vertex.position },
                }),
            })),
        };
    }
}

// ============================================================================
// Pre-operation Capture
// ============================================================================

/**
 * Capture edge info before fillet
 */
export function captureEdgeInfo(
    shape: ReplicadShape,
    featureId: string
): PreFilletEdgeInfo[] {
    const analyzer = new ShapeAnalyzer(shape, featureId, '', '');
    const edges = analyzer.analyzeEdges();
    const tracker = getTopologyTracker();

    return edges.map(edge => {
        const stableId = tracker.getStableIdForIndex(featureId, 'edge', edge.index);
        return {
            featureId,
            edgeIndex: edge.index,
            stableId,
            signature: edge.signature,
            adjacentFaceIndices: [], // Would need more analysis
        };
    });
}

/**
 * Capture face info before fillet
 */
export function captureFaceInfoForFillet(
    shape: ReplicadShape,
    featureId: string
): PreFilletFaceInfo[] {
    const analyzer = new ShapeAnalyzer(shape, featureId, '', '');
    const faces = analyzer.analyzeFaces();
    const tracker = getTopologyTracker();

    return faces.map(face => {
        const stableId = tracker.getStableIdForIndex(featureId, 'face', face.index);
        return {
            featureId,
            faceIndex: face.index,
            stableId,
            signature: face.signature,
        };
    });
}

// ============================================================================
// Factory Functions
// ============================================================================

/**
 * Analyze fillet operation
 */
export function analyzeFillet(
    resultShape: ReplicadShape,
    featureId: string,
    operationId: string,
    params: FilletParams,
    originalEdges: PreFilletEdgeInfo[],
    originalFaces: PreFilletFaceInfo[]
): FilletAnalysisResult {
    const analyzer = new FilletAnalyzer(
        resultShape, featureId, operationId, params, originalEdges, originalFaces
    );
    return analyzer.analyze();
}

/**
 * Register fillet with tracker
 */
export function registerFilletWithTracker(
    resultShape: ReplicadShape,
    featureId: string,
    operationId: string,
    params: FilletParams,
    originalEdges: PreFilletEdgeInfo[],
    originalFaces: PreFilletFaceInfo[]
): FilletAnalysisResult {
    const tracker = getTopologyTracker();
    tracker.beginOperation(params.type);

    const result = analyzeFillet(
        resultShape, featureId, operationId, params, originalEdges, originalFaces
    );

    // Register all faces
    for (const face of result.filletFaces) {
        tracker.registerFace(
            featureId,
            face.faceIndex,
            face.stableId.generatorLinks,
            face.stableId.geometricSignature,
            face.stableId.label
        );
    }

    for (const face of result.modifiedFaces) {
        tracker.registerFace(
            featureId,
            face.faceIndex,
            face.stableId.generatorLinks,
            face.stableId.geometricSignature,
            face.stableId.label
        );
    }

    for (const face of result.unchangedFaces) {
        tracker.registerFace(
            featureId,
            face.faceIndex,
            face.stableId.generatorLinks,
            face.stableId.geometricSignature,
            face.stableId.label
        );
    }

    // Register edges and vertices
    for (const edge of result.edges) {
        tracker.registerEdge(
            featureId,
            edge.edgeIndex,
            edge.stableId.generatorLinks,
            edge.stableId.geometricSignature,
            edge.stableId.label
        );
    }

    for (const vertex of result.vertices) {
        tracker.registerVertex(
            featureId,
            vertex.vertexIndex,
            vertex.stableId.generatorLinks,
            vertex.stableId.geometricSignature?.centroid as [number, number, number] || [0, 0, 0],
            vertex.stableId.label
        );
    }

    tracker.endOperation();

    return result;
}
